# 문제 1

NestJS 기반의 백엔드 서비스에서 **사용자 등록 API**를 구현하세요.

이 API는 새로운 사용자를 등록하고, 비밀번호를 안전하게 저장해야 합니다.

## 요구사항

**1. API 엔드포인트 -** POST /users

요청 바디 예시

```jsx
{
"name": "John Doe",
"email": "[john@example.com](mailto:john@example.com)",
"password": "securePassword123"
}
```

성공시 응답

```jsx
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-01-21T07:33:37.696Z"
}
```

실패시 응답

```jsx
{
  "statusCode": 409,
  "message": "Email already exists"
}
```

```jsx
{
  "statusCode": 400,
  "message": "Password must be at least 8 characters long"
}
```

**유효성 검사**

- name 필드는 최소 2자 이상, 최대 50자 이내여야 합니다.
- email 필드는 올바른 이메일 형식이어야 합니다.
- password는 최소 8자 이상이어야 하며, 숫자와 문자가 포함되어야 합니다.

**이메일 중복 검사**

- 이미 존재하는 이메일로 회원가입을 시도하면 409 Conflict 응답을 반환해야 합니다.

**비밀번호 해싱**

- 비밀번호를 암호화 하여 안전하게 저장해야 합니다.

**에러 핸들링**

- 입력값이 올바르지 않을 경우 400 Bad Request를 반환해야 합니다.

**데이터베이스 연동 (TypeORM 사용)**

- MySQL을 사용하며, **TypeORM 엔터티**를 정의하여 데이터를 저장해야 합니다.

---

### 💡 추가질문 - 비밀번호 해싱처리는 왜 하는걸까요?
비밀번호를 평문으로 저장했을 시, 데이터베이스가 해킹당하면 사용자들의 비밀번호가 그대로 유출될 위험이 있습니다.  
하지만 해싱 처리를 하게되면 비밀번호가 일방향 암호화 방식으로 변환되기 때문에 해시값을 얻어도 원래 비밀번호로 복원할 수 없게 됩니다.  
그러나 같은 비밀번호를 사용한 경우 동일한 해시값이 생성되기 때문에, 해커가 이를 활용해 대입 공격을 시도할 가능성이 있습니다.  
이 문제를 방지하기 위해서 솔트(Salt)를 추가하면 각 비밀번호마다 랜덤한 값이 추가되어 해시값이 달라지게 되기 때문에 보안을 더 강화할 수 있습니다.  
또한, 해커가 미리 계산된 해시값 목록(레인보우 테이블) 을 사용하여 해시값을 비밀번호로 역변환하는 공격을 시도할 경우에도 솔트를 적용 시 각 사용자의 해시값이 달라지므로 레인보우 테이블 공격에서 안전할 수 있습니다.  
또 다른 이유로는 대부분의 보안 규정 및 정책에서 비밀번호를 평문으로 저장하지 않도록 명시하고 있기 때문입니다. 해싱을 사용하면 법적 요구사항과 보안 가이드를 준수할 수 있습니다.  
마지막으로 회사 내부에서 DB 접근 권한을 가진 사람이더라도 사용자 비밀번호를 직접 볼 수 없도록 보호할 수 있기 때문입니다.